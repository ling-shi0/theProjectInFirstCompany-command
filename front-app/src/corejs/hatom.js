import Vue from 'vue'; import Router from 'vue-router'; Vue.use(Router); const router = new Router({ routes: [] }); const vueRouter = {};['match', 'init', 'beforeEach', 'beforeResolve', 'afterEach', 'onReady', 'onError', 'push', 'replace', 'go', 'back', 'forward', 'getMatchedComponents', 'resolve', 'addRoutes'].forEach((method) => { vueRouter[method] = (...args) => { router[method](...args) } }); function setupWebViewJavascriptBridge(callback) { if (window.WebViewJavascriptBridge) { callback(WebViewJavascriptBridge) } else { document.addEventListener('WebViewJavascriptBridgeReady', function () { callback(WebViewJavascriptBridge) }, false) } } class Plugin { constructor() { setupWebViewJavascriptBridge(function (bridge) { bridge.init() }); this.router = vueRouter; this.isMobile = getIsMobile() } setBridge(funcName, callbackFunc) { try { setupWebViewJavascriptBridge(function (bridge) { bridge.registerHandler(funcName, callbackFunc) }) } catch (err) { console.error(err) } } native(funcName, callbackFunc, args = {}) { if (args && typeof args === 'object' && Object.prototype.toString.call(args).toLowerCase() === '[object object]' && !args.length) { args = JSON.stringify(args) } else { console.error('args不符合规范') } if (getIsMobile()) { window.WebViewJavascriptBridge.callHandler(funcName, args, (res) => { res = JSON.parse(res); if (res.code === 0) { return callbackFunc(res) } else { console.log(res.message) } }) } else { } } camera(callbackFunc, args = {}) { const options = { mQuality: args.mQuality || '50', destType: args.destType || '1', srcType: args.srcType || '1', targetWidth: args.targetWidth || '-1', targetHeight: args.targetHeight || '-1', encodingType: args.encodingType || '0', mediaType: args.mediaType || '0', allowEdit: args.allowEdit || false, correctOrientation: args.correctOrientation || false, saveToPhotoAlbum: args.saveToPhotoAlbum || false }; this.native('CameraLauncher.takePicture', callbackFunc, options) } networkManager(callbackFunc) { this.native('NetworkManagerPlugin.registerNetWorkReceiver', callbackFunc) } phoneCall(callbackFunc, args = {}) { this.native('System.phoneCall', callbackFunc, args) } sharePic(callbackFunc, args = {}) { this.native('System.sharePic', callbackFunc, args) } shareText(callbackFunc, args = {}) { this.native('System.shareText', callbackFunc, args) } } const hatom = new Plugin(); hatom.router.goPage = (route) => { if (getIsMobile()) { hatom.native('Router.pushPage', (res) => { }, route) } else { window.location.href = route.params.test } }; hatom.locationInfo = {};['getLocation', 'getLocationPermission', 'turnOffLocation'].forEach((method) => { hatom.locationInfo[method] = (callbackFunc) => { hatom.native(`GetLocationInfoPlugin.${method}`, callbackFunc) } }); hatom.goMapApp = (callbackFunc, params) => { hatom.native('GetMapAppPlugin.getMapApp', callbackFunc, params) }; hatom.scan = (callbackFunc) => { hatom.native('BarcodeScannerPlugin.scan', callbackFunc) }; hatom.singleRealPlay = {};['realPlay', 'playBack'].forEach((method) => { hatom.singleRealPlay[method] = (callbackFunc, params) => { hatom.native(`SingleRealPlay.${method}`, callbackFunc, params) } }); hatom.rootInfo = {};['getRootInfo', 'redirectLogin'].forEach((method) => { hatom.rootInfo[method] = (callbackFunc) => { hatom.native(`GetRootInfoPlugin.${method}`, callbackFunc) } }); hatom.setting = {};['updateApp', 'logout', 'modifyPassword', 'gotoSetting', 'gestureSetting', 'messageSetting', 'cameraFaceRecognition', 'getStatusInfo'].forEach((method) => { hatom.setting[method] = (callbackFunc) => { hatom.native(`SettingPlugin.${method}`, callbackFunc) } }); hatom.page = { preload: (callbackFunc, params) => { hatom.native('Router.preload', callbackFunc, params) }, exit: (callbackFunc) => { hatom.native('Router.exitWebApp', callbackFunc) }, popPage: (route) => { if (getIsMobile()) { hatom.native('Router.popPage', (res) => { }, route) } else { if (route) { window.location.hash = ''; window.location.pathname = route.params.page } else { window.history.back() } } }, pushPage: (route) => { if (getIsMobile()) { hatom.native('Router.pushPage', (res) => { }, route) } else { window.location.hash = ''; window.location.pathname = route.params.page } }, back: (callbackFunc, params) => { if (getIsMobile()) { hatom.native('Router.popPage', callbackFunc, params) } else { window.history.back() } }, cleanCache: (callbackFunc) => { hatom.native('Router.cleanCache', callbackFunc) } }; hatom.message = {};['startMessage', 'stopMessage'].forEach((method) => { hatom.message[method] = (callbackFunc, params) => { hatom.native(`PushMessagePlugin.${method}Push`, callbackFunc, params) } }); hatom.topBar = {};['setTopBarLeftButton', 'setTopBarRightButton', 'setTopBarTitle', 'setTopBarBackground'].forEach((method) => { hatom.topBar[method] = (callbackFunc, params) => { hatom.native(`topbar.${method}`, callbackFunc, params) } }); hatom.bottomBar = {};['setItemConfig', 'selectItem', 'setBadge'].forEach((method) => { hatom.bottomBar[method] = (callbackFunc, params) => { hatom.native(`bottomNavigation.${method}`, callbackFunc, params) } }); hatom.storage = { setItem: (key, value) => { if (getIsMobile()) { const obj = {}; obj[key] = value; hatom.native('DataSharePlugin.saveData', (res) => { }, obj) } else { window.localStorage.setItem(key, value) } }, getItem: (key, callbackFunc) => { if (getIsMobile()) { const obj = {}; obj[key] = key; hatom.native('DataSharePlugin.getData', callbackFunc, obj) } else { const res = window.localStorage.getItem(key); callbackFunc(res) } } }; hatom.getScreenInfo = (callbackFunc) => { hatom.native('Device.getScreenInfo', callbackFunc) }; hatom.getSyncScreenInfo = async () => { return new Promise((resolve) => { hatom.native('Device.getScreenInfo', async (res) => { resolve(res) }) }) }; hatom.deviceScreenInfo = { getScreenInfo: (callbackFunc) => { hatom.native('Device.getScreenInfo', callbackFunc) }, getSyncScreenInfo: async () => { return new Promise((resolve) => { hatom.native('Device.getScreenInfo', async (res) => { if (res.code === '0') { const screenInfo = JSON.parse(res.message); resolve(screenInfo) } else { resolve({}) } }) }) }, getStatusBarHeight: () => { const res = this.getSyncScreenInfo(); if (res.code === '0') { const screenInfo = JSON.parse(res.message); return screenInfo.statusBarHeight / screenInfo.screenDensity } else { return 0 } }, getScreenWidth: () => { const res = this.getSyncScreenInfo(); if (res.code === '0') { const screenInfo = JSON.parse(res.message); return screenInfo.getScreenWidth } else { return 0 } }, getScreenScreenRotation: () => { const res = this.getSyncScreenInfo(); if (res.code === '0') { const screenInfo = JSON.parse(res.message); return screenInfo.screenScreenRotation } else { return 0 } }, getScreenHeight: () => { const res = this.getSyncScreenInfo(); if (res.code === '0') { const screenInfo = JSON.parse(res.message); return screenInfo.screenHeight } else { return 0 } } }; hatom.statusBar = { setStatusBarMode: (data, callbackFunc) => { hatom.native('StatusBar.setStatusBarMode', callbackFunc, data) } }; function getIsMobile() { const p = window.navigator.platform; const isMobile = p.indexOf('Linux arm') > -1 || p.indexOf('iphone') > -1 || p.indexOf('Linux') > -1 || p.indexOf('iPhone') > -1 || p.indexOf('ipad') > -1 || p.indexOf('iPad') > -1 || p.indexOf('MacIntel') > -1; return isMobile }; window.hatom = hatom; const install = (Vue) => { Vue.prototype.$hatom = hatom }; export default install